{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"RocksDB KV Transactions","text":"<p>Type-safe key-value transactions backed by RocksDB.</p>"},{"location":"#overview","title":"Overview","text":"<p>This library provides a transactional layer over RocksDB with:</p> <ul> <li>Type-safe columns - Each column has its own key and value types, enforced at compile time</li> <li>Snapshot isolation - All reads within a transaction see a consistent point-in-time view</li> <li>Atomic transactions - Buffered writes are applied atomically on commit</li> <li>Speculation - Read-your-writes transactions that discard mutations, for computing derived results</li> <li>Cursor iteration - Range queries with forward/backward navigation</li> <li>Serialization via Prisms - Flexible encoding/decoding using lens prisms</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Add to your <code>build-depends</code>:</p> <pre><code>build-depends:\n    rocksdb-kv-transactions\n    rocksdb-kv-transactions:kv-transactions\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>{-# LANGUAGE GADTs #-}\n\nimport Data.ByteString (ByteString)\nimport Data.Type.Equality ((:~:)(..))\nimport Database.KV.RocksDB (mkRocksDBDatabase)\nimport Database.KV.Transaction\nimport Database.RocksDB\n\n-- Define your columns as a GADT\ndata Columns c where\n    Users :: Columns (KV ByteString ByteString)\n    Posts :: Columns (KV ByteString ByteString)\n\n-- Required instances for DMap lookup\ninstance GCompare Columns where\n    gcompare Users Users = GEQ\n    gcompare Posts Posts = GEQ\n    gcompare Users Posts = GLT\n    gcompare Posts Users = GGT\n\ninstance GEq Columns where\n    geq Users Users = Just Refl\n    geq Posts Posts = Just Refl\n    geq _ _ = Nothing\n\n-- Define codecs (identity for ByteString)\ncodecs :: DMap Columns Codecs\ncodecs = fromPairList\n    [ Users :=&gt; Codecs id id\n    , Posts :=&gt; Codecs id id\n    ]\n\nmain :: IO ()\nmain = do\n    -- Open database with column families\n    withDBCF \"mydb\" cfg [(\\\"users\\\", cfg), (\\\"posts\\\", cfg)] $ \\db -&gt; do\n        let database = mkRocksDBDatabase db (mkColumns (columnFamilies db) codecs)\n\n        -- Run transactions\n        runTransactionUnguarded database $ do\n            insert Users \"user1\" \"Alice\"\n            insert Users \"user2\" \"Bob\"\n\n        -- Query data\n        result &lt;- runTransactionUnguarded database $ do\n            query Users \"user1\"\n\n        print result  -- Just \"Alice\"\n  where\n    cfg = def { createIfMissing = True }\n</code></pre>"},{"location":"#modules","title":"Modules","text":""},{"location":"#kv-transactions-sublibrary","title":"kv-transactions (sublibrary)","text":"Module Description <code>Database.KV.Transaction</code> Core transaction monad with <code>query</code>, <code>insert</code>, <code>delete</code> <code>Database.KV.Database</code> Abstract database interface and column definitions <code>Database.KV.Query</code> Read-only queries (no write buffering) <code>Database.KV.Cursor</code> Iterator-based navigation (<code>firstEntry</code>, <code>nextEntry</code>, <code>seekKey</code>)"},{"location":"#rocksdb-kv-transactions-main-library","title":"rocksdb-kv-transactions (main library)","text":"Module Description <code>Database.KV.RocksDB</code> RocksDB backend implementation"},{"location":"#development","title":"Development","text":"<pre><code># Enter nix shell\nnix develop\n\n# Build\njust build\n\n# Run tests\njust test\n\n# Format code\njust format\n\n# Full CI\njust ci\n</code></pre>"},{"location":"#license","title":"License","text":"<p>Apache-2.0</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#databasekvtransaction","title":"Database.KV.Transaction","text":""},{"location":"api/#core-operations","title":"Core Operations","text":""},{"location":"api/#query","title":"query","text":"<pre><code>query :: (GCompare t, Ord (KeyOf c))\n      =&gt; t c           -- Column selector\n      -&gt; KeyOf c       -- Key to look up\n      -&gt; Transaction m cf t op (Maybe (ValueOf c))\n</code></pre> <p>Read a value from a column. First checks the workspace for pending changes, then falls back to the database.</p>"},{"location":"api/#insert","title":"insert","text":"<pre><code>insert :: (GCompare t, Ord (KeyOf c))\n       =&gt; t c          -- Column selector\n       -&gt; KeyOf c      -- Key\n       -&gt; ValueOf c    -- Value to insert\n       -&gt; Transaction m cf t op ()\n</code></pre> <p>Buffer an insert operation. The actual write occurs when the transaction commits.</p>"},{"location":"api/#delete","title":"delete","text":"<pre><code>delete :: (GCompare t, Ord (KeyOf c))\n       =&gt; t c          -- Column selector\n       -&gt; KeyOf c      -- Key to delete\n       -&gt; Transaction m cf t op ()\n</code></pre> <p>Buffer a delete operation. The actual delete occurs when the transaction commits.</p>"},{"location":"api/#cursor-operations","title":"Cursor Operations","text":""},{"location":"api/#iterating","title":"iterating","text":"<pre><code>iterating :: GCompare t\n          =&gt; t c                                    -- Column selector\n          -&gt; Cursor (Transaction m cf t op) c a     -- Cursor program\n          -&gt; Transaction m cf t op a\n</code></pre> <p>Run a cursor program over a column within the transaction.</p>"},{"location":"api/#running-transactions","title":"Running Transactions","text":""},{"location":"api/#runtransactionunguarded","title":"runTransactionUnguarded","text":"<pre><code>runTransactionUnguarded :: (GCompare t, MonadFail m)\n                        =&gt; Database m cf t op\n                        -&gt; Transaction m cf t op b\n                        -&gt; m b\n</code></pre> <p>Run a transaction without concurrency control. All reads target a consistent snapshot. Use only in single-threaded contexts.</p>"},{"location":"api/#runspeculation","title":"runSpeculation","text":"<pre><code>runSpeculation :: (GCompare t, MonadFail m)\n               =&gt; Database m cf t op\n               -&gt; Transaction m cf t op b\n               -&gt; m b\n</code></pre> <p>Run a transaction speculatively. Reads from a consistent snapshot with read-your-writes in the workspace, but discards all writes at the end. No mutations are applied to the database. Useful for computing derived results (trie roots, proofs) without side effects.</p>"},{"location":"api/#newruntransaction","title":"newRunTransaction","text":"<pre><code>newRunTransaction :: (MonadIO m, MonadIO n, MonadMask n, GCompare t, MonadFail n)\n                  =&gt; Database n cf t op\n                  -&gt; m (RunTransaction n cf t op)\n</code></pre> <p>Create a serialized transaction runner using mutex synchronization.</p>"},{"location":"api/#databasekvcursor","title":"Database.KV.Cursor","text":""},{"location":"api/#navigation","title":"Navigation","text":""},{"location":"api/#firstentry","title":"firstEntry","text":"<pre><code>firstEntry :: Cursor m c (Maybe (Entry c))\n</code></pre> <p>Move to the first entry (lexicographically smallest key).</p>"},{"location":"api/#lastentry","title":"lastEntry","text":"<pre><code>lastEntry :: Cursor m c (Maybe (Entry c))\n</code></pre> <p>Move to the last entry (lexicographically largest key).</p>"},{"location":"api/#nextentry","title":"nextEntry","text":"<pre><code>nextEntry :: Cursor m c (Maybe (Entry c))\n</code></pre> <p>Move to the next entry. Returns <code>Nothing</code> if at end.</p>"},{"location":"api/#preventry","title":"prevEntry","text":"<pre><code>prevEntry :: Cursor m c (Maybe (Entry c))\n</code></pre> <p>Move to the previous entry. Returns <code>Nothing</code> if at beginning.</p>"},{"location":"api/#seekkey","title":"seekKey","text":"<pre><code>seekKey :: KeyOf c -&gt; Cursor m c (Maybe (Entry c))\n</code></pre> <p>Seek to a specific key. If the exact key is not found, positions at the next key.</p>"},{"location":"api/#types","title":"Types","text":""},{"location":"api/#entry","title":"Entry","text":"<pre><code>data Entry c = Entry\n    { entryKey   :: KeyOf c\n    , entryValue :: ValueOf c\n    }\n</code></pre> <p>A key-value pair with types determined by the column.</p>"},{"location":"api/#databasekvdatabase","title":"Database.KV.Database","text":""},{"location":"api/#types_1","title":"Types","text":""},{"location":"api/#kv","title":"KV","text":"<pre><code>data KV k v\n</code></pre> <p>Phantom type representing a key-value pair in a collection.</p>"},{"location":"api/#codecs","title":"Codecs","text":"<pre><code>data Codecs c = Codecs\n    { keyCodec   :: Prism' ByteString (KeyOf c)\n    , valueCodec :: Prism' ByteString (ValueOf c)\n    }\n</code></pre> <p>Codecs for encoding and decoding keys and values.</p>"},{"location":"api/#column","title":"Column","text":"<pre><code>data Column cf c = Column\n    { family :: cf\n    , codecs :: Codecs c\n    }\n</code></pre> <p>A column definition with backend-specific identifier and codecs.</p>"},{"location":"api/#database","title":"Database","text":"<pre><code>data Database m cf t op = Database\n    { valueAt      :: cf -&gt; ByteString -&gt; m (Maybe ByteString)\n    , applyOps     :: [op] -&gt; m ()\n    , mkOperation  :: cf -&gt; ByteString -&gt; Maybe ByteString -&gt; op\n    , newIterator  :: cf -&gt; m (QueryIterator m)\n    , columns      :: DMap t (Column cf)\n    , withSnapshot :: forall a. (Database m cf t op -&gt; m a) -&gt; m a\n    }\n</code></pre> <p>Backend-agnostic database interface. The <code>withSnapshot</code> field provides a consistent snapshot of the database for atomic reads. The callback receives a <code>Database</code> whose <code>valueAt</code> and <code>newIterator</code> all operate on the same frozen point.</p>"},{"location":"api/#functions","title":"Functions","text":""},{"location":"api/#mkcolumns","title":"mkColumns","text":"<pre><code>mkColumns :: [cf] -&gt; DMap k Codecs -&gt; DMap k (Column cf)\n</code></pre> <p>Create columns from a list of column families and codecs.</p>"},{"location":"api/#frompairlist","title":"fromPairList","text":"<pre><code>fromPairList :: GCompare t =&gt; [DSum t r] -&gt; DMap t r\n</code></pre> <p>Create a DMap from a list of typed pairs.</p>"},{"location":"api/#databasekvrocksdb","title":"Database.KV.RocksDB","text":""},{"location":"api/#functions_1","title":"Functions","text":""},{"location":"api/#mkrocksdbdatabase","title":"mkRocksDBDatabase","text":"<pre><code>mkRocksDBDatabase :: DB -&gt; DMap t (Column ColumnFamily) -&gt; Database IO ColumnFamily t BatchOp\n</code></pre> <p>Create a RocksDB-backed database from a DB handle and column map.</p>"},{"location":"architecture/cursors/","title":"Cursor Architecture","text":""},{"location":"architecture/cursors/#overview","title":"Overview","text":"<p>Cursors provide iterator-based access for range queries. They allow forward and backward navigation through sorted key-value entries.</p>"},{"location":"architecture/cursors/#cursor-operations","title":"Cursor Operations","text":"<p>The cursor API provides five core operations:</p> Operation Description <code>firstEntry</code> Move to the first (smallest key) entry <code>lastEntry</code> Move to the last (largest key) entry <code>nextEntry</code> Move to the next entry <code>prevEntry</code> Move to the previous entry <code>seekKey</code> Seek to a specific key (or next if not found)"},{"location":"architecture/cursors/#operational-monad","title":"Operational Monad","text":"<p>Like transactions, cursors use the operational monad pattern:</p> <pre><code>data CursorInstruction m c a where\n    FirstEntry :: CursorInstruction m c (Maybe (Entry c))\n    LastEntry  :: CursorInstruction m c (Maybe (Entry c))\n    NextEntry  :: CursorInstruction m c (Maybe (Entry c))\n    PrevEntry  :: CursorInstruction m c (Maybe (Entry c))\n    SeekKey    :: KeyOf c -&gt; CursorInstruction m c (Maybe (Entry c))\n\ntype Cursor m c = ProgramT (CursorInstruction m c) m\n</code></pre>"},{"location":"architecture/cursors/#entry-type","title":"Entry Type","text":"<p>Entries contain decoded key-value pairs:</p> <pre><code>data Entry c = Entry\n    { entryKey   :: KeyOf c\n    , entryValue :: ValueOf c\n    }\n</code></pre>"},{"location":"architecture/cursors/#iterator-positions","title":"Iterator Positions","text":"<p>The underlying iterator responds to position commands:</p> <pre><code>data Pos\n    = PosFirst      -- Move to first entry\n    | PosLast       -- Move to last entry\n    | PosNext       -- Move to next entry\n    | PosPrev       -- Move to previous entry\n    | PosAny BS     -- Seek to specific key\n    | PosDestroy    -- Release iterator\n</code></pre>"},{"location":"architecture/cursors/#backend-interface","title":"Backend Interface","text":"<p>The <code>QueryIterator</code> provides a backend-agnostic iterator:</p> <pre><code>data QueryIterator m = QueryIterator\n    { step    :: Pos -&gt; m ()           -- Move to position\n    , isValid :: m Bool                -- Check if pointing to valid entry\n    , entry   :: m (Maybe (BS, BS))    -- Get current key-value pair\n    }\n</code></pre>"},{"location":"architecture/cursors/#example-usage","title":"Example Usage","text":""},{"location":"architecture/cursors/#sequential-iteration","title":"Sequential Iteration","text":"<pre><code>runTransactionUnguarded database $ iterating Users $ do\n    first &lt;- firstEntry\n    second &lt;- nextEntry\n    third &lt;- nextEntry\n    pure (first, second, third)\n</code></pre>"},{"location":"architecture/cursors/#range-query","title":"Range Query","text":"<pre><code>runTransactionUnguarded database $ iterating Users $ do\n    -- Start from \"user_100\"\n    entry &lt;- seekKey \"user_100\"\n    -- Get next 10 entries\n    entries &lt;- replicateM 10 nextEntry\n    pure entries\n</code></pre>"},{"location":"architecture/cursors/#backward-iteration","title":"Backward Iteration","text":"<pre><code>runTransactionUnguarded database $ iterating Users $ do\n    last &lt;- lastEntry\n    prev1 &lt;- prevEntry\n    prev2 &lt;- prevEntry\n    pure (last, prev1, prev2)\n</code></pre>"},{"location":"architecture/cursors/#lifecycle","title":"Lifecycle","text":"<p>Cursor operations are scoped within <code>iterating</code>:</p> <ol> <li>Iterator is created when entering <code>iterating</code></li> <li>Cursor operations move the iterator position</li> <li>Iterator is automatically destroyed when leaving <code>iterating</code></li> </ol> <pre><code>iterating :: t c -&gt; Cursor (Transaction m cf t op) c a -&gt; Transaction m cf t op a\n</code></pre>"},{"location":"architecture/overview/","title":"Architecture Overview","text":""},{"location":"architecture/overview/#design-philosophy","title":"Design Philosophy","text":"<p>The library is built around four core principles:</p> <ol> <li>Type Safety - Column keys and values are typed at compile time</li> <li>Modularity - Backend-agnostic abstractions with RocksDB implementation</li> <li>Composability - Transaction operations compose monadically</li> <li>Snapshot Isolation - All reads within a transaction see a consistent point-in-time view</li> </ol>"},{"location":"architecture/overview/#component-diagram","title":"Component Diagram","text":"<pre><code>graph TB\n    subgraph \"Application Layer\"\n        TX[Transaction Monad]\n        SPEC[Speculation]\n        CUR[Cursor Operations]\n    end\n\n    subgraph \"Abstraction Layer\"\n        DB[Database Interface]\n        COL[Column Definitions]\n        COD[Codecs]\n    end\n\n    subgraph \"Storage Layer\"\n        ROCKS[RocksDB Backend]\n        CF[Column Families]\n        SNAP[Snapshots]\n    end\n\n    TX --&gt; DB\n    SPEC --&gt; DB\n    CUR --&gt; DB\n    DB --&gt; COL\n    COL --&gt; COD\n    DB --&gt; ROCKS\n    ROCKS --&gt; CF\n    ROCKS --&gt; SNAP</code></pre>"},{"location":"architecture/overview/#library-structure","title":"Library Structure","text":"<pre><code>rocksdb-kv-transactions/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 kv-transactions/          # Internal sublibrary\n\u2502   \u2502   \u2514\u2500\u2500 Database/KV/\n\u2502   \u2502       \u251c\u2500\u2500 Database.hs       # Core abstractions\n\u2502   \u2502       \u251c\u2500\u2500 Transaction.hs    # Transaction monad\n\u2502   \u2502       \u251c\u2500\u2500 Cursor.hs         # Iterator operations\n\u2502   \u2502       \u2514\u2500\u2500 Query.hs          # Read-only queries\n\u2502   \u2514\u2500\u2500 rocksdb-kv-transactions/  # Main library\n\u2502       \u2514\u2500\u2500 Database/KV/\n\u2502           \u2514\u2500\u2500 RocksDB.hs        # RocksDB backend\n\u2514\u2500\u2500 test/                         # Unit tests\n</code></pre>"},{"location":"architecture/overview/#type-safe-columns","title":"Type-Safe Columns","text":"<p>The key innovation is using GADTs to define typed column selectors:</p> <pre><code>data Columns c where\n    Users :: Columns (KV UserId User)\n    Posts :: Columns (KV PostId Post)\n</code></pre> <p>The <code>KV</code> phantom type carries the key and value types:</p> <pre><code>data KV k v\n\ntype family KeyOf c where\n    KeyOf (KV k v) = k\n\ntype family ValueOf c where\n    ValueOf (KV k v) = v\n</code></pre> <p>This ensures that <code>query Users someKey</code> only typechecks if <code>someKey :: UserId</code>.</p>"},{"location":"architecture/overview/#dmap-for-heterogeneous-storage","title":"DMap for Heterogeneous Storage","text":"<p>Column metadata is stored in a <code>DMap</code> (dependent map) which allows different value types per key:</p> <pre><code>columns :: DMap Columns (Column cf)\ncodecs  :: DMap Columns Codecs\n</code></pre> <p>This is enabled by the <code>dependent-map</code> package and requires <code>GCompare</code> instances.</p>"},{"location":"architecture/transactions/","title":"Transaction Architecture","text":""},{"location":"architecture/transactions/#operational-monad-pattern","title":"Operational Monad Pattern","text":"<p>Transactions are built using the operational monad pattern from the <code>operational</code> package. This separates the description of operations from their interpretation:</p> <pre><code>data TransactionInstruction m cf t op a where\n    Query    :: t c -&gt; KeyOf c -&gt; TransactionInstruction m cf t op (Maybe (ValueOf c))\n    Insert   :: t c -&gt; KeyOf c -&gt; ValueOf c -&gt; TransactionInstruction m cf t op ()\n    Delete   :: t c -&gt; KeyOf c -&gt; TransactionInstruction m cf t op ()\n    Iterating :: t c -&gt; Cursor (...) c a -&gt; TransactionInstruction m cf t op a\n    Reset    :: Maybe (t c) -&gt; TransactionInstruction m cf t op ()\n\ntype Transaction m cf t op = ProgramT (TransactionInstruction m cf t op) (Context cf t op m)\n</code></pre>"},{"location":"architecture/transactions/#execution-model","title":"Execution Model","text":"<p>Transactions use an optimistic approach with snapshot isolation:</p> <pre><code>sequenceDiagram\n    participant App as Application\n    participant Tx as Transaction\n    participant WS as Workspace\n    participant Snap as Snapshot\n    participant DB as Database\n\n    App-&gt;&gt;Tx: runTransactionUnguarded tx\n    Tx-&gt;&gt;DB: withSnapshot\n    DB--&gt;&gt;Snap: Create consistent snapshot\n    Tx-&gt;&gt;WS: Initialize empty workspaces\n    loop For each operation\n        alt Query\n            Tx-&gt;&gt;WS: Check workspace\n            alt Found in workspace\n                WS--&gt;&gt;Tx: Return cached value\n            else Not in workspace\n                Tx-&gt;&gt;Snap: Read from snapshot\n                Snap--&gt;&gt;Tx: Return value\n            end\n        else Insert/Delete\n            Tx-&gt;&gt;WS: Buffer operation\n        end\n    end\n    Tx-&gt;&gt;WS: Collect all buffered operations\n    Tx-&gt;&gt;DB: Apply atomically\n    DB--&gt;&gt;App: Return result</code></pre>"},{"location":"architecture/transactions/#snapshot-isolation","title":"Snapshot Isolation","text":"<p>All reads within a transaction target the same consistent snapshot. Concurrent writes to the database do not affect queries within an in-flight transaction.</p> <p>The snapshot is created at the start of <code>runTransactionUnguarded</code> (or <code>runSpeculation</code>) via the <code>withSnapshot</code> field on <code>Database</code>. The snapshot-backed <code>Database</code> is passed into the <code>ReaderT</code> that <code>interpretTransaction</code> runs in, so every <code>interpretQuery</code> call reads from the same frozen point.</p>"},{"location":"architecture/transactions/#workspace-buffering","title":"Workspace Buffering","text":"<p>Each column has its own workspace that buffers pending changes:</p> <pre><code>newtype Workspace c = Workspace (Map (KeyOf c) (Maybe (ValueOf c)))\n\ntype Workspaces t = DMap t Workspace\n</code></pre> <ul> <li><code>Just value</code> indicates a pending insert</li> <li><code>Nothing</code> indicates a pending delete</li> </ul>"},{"location":"architecture/transactions/#read-your-writes-semantics","title":"Read-Your-Writes Semantics","text":"<p>Queries first check the workspace before hitting the database:</p> <pre><code>interpretQuery t k = do\n    workspaces &lt;- get\n    case DMap.lookup t workspaces of\n        Just (Workspace ws) -&gt;\n            maybe fetchFromDB pure $ Map.lookup k ws\n        Nothing -&gt; fetchFromDB\n</code></pre> <p>This ensures you see your own uncommitted writes within a transaction.</p>"},{"location":"architecture/transactions/#concurrency-control","title":"Concurrency Control","text":"<p>Two options for running transactions:</p>"},{"location":"architecture/transactions/#unguarded-single-threaded","title":"Unguarded (Single-threaded)","text":"<pre><code>runTransactionUnguarded :: Database m cf t op -&gt; Transaction m cf t op a -&gt; m a\n</code></pre> <p>No synchronization - use only when you can guarantee single-threaded access.</p>"},{"location":"architecture/transactions/#serialized-multi-threaded","title":"Serialized (Multi-threaded)","text":"<pre><code>newRunTransaction :: Database n cf t op -&gt; m (RunTransaction n cf t op)\n\nrunner &lt;- newRunTransaction db\nforkIO $ runTransaction runner tx1\nforkIO $ runTransaction runner tx2\n</code></pre> <p>Uses an MVar mutex to ensure only one transaction executes at a time.</p>"},{"location":"architecture/transactions/#atomic-commit","title":"Atomic Commit","text":"<p>At the end of a transaction, all buffered operations are converted to batch operations and applied atomically:</p> <pre><code>ops &lt;- mapM toBatchOps $ DMap.toList workspaces\napplyOps $ concat ops\n</code></pre> <p>RocksDB guarantees atomic batch writes.</p>"},{"location":"architecture/transactions/#speculation","title":"Speculation","text":"<p><code>runSpeculation</code> executes a transaction against a snapshot with read-your-writes in the workspace, but discards all writes at the end. No mutations are applied to the database.</p> <pre><code>sequenceDiagram\n    participant App as Application\n    participant Tx as Transaction\n    participant WS as Workspace\n    participant Snap as Snapshot\n\n    App-&gt;&gt;Tx: runSpeculation tx\n    Tx-&gt;&gt;Snap: Create snapshot\n    Tx-&gt;&gt;WS: Initialize empty workspaces\n    loop For each operation\n        alt Query\n            Tx-&gt;&gt;WS: Check workspace\n            alt Found in workspace\n                WS--&gt;&gt;Tx: Return cached value\n            else Not in workspace\n                Tx-&gt;&gt;Snap: Read from snapshot\n                Snap--&gt;&gt;Tx: Return value\n            end\n        else Insert/Delete\n            Tx-&gt;&gt;WS: Buffer operation\n        end\n    end\n    Note over WS: Workspace discarded\n    Tx--&gt;&gt;App: Return result only</code></pre> <p>Use speculation for computing derived results (trie roots, proofs) without side effects.</p>"}]}